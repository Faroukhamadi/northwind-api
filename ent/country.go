// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"

	"entgo.io/ent/dialect/sql"
	"github.com/Faroukhamadi/northwind-api/ent/city"
	"github.com/Faroukhamadi/northwind-api/ent/country"
	"github.com/Faroukhamadi/northwind-api/ent/country_language"
)

// Country is the model entity for the Country schema.
type Country struct {
	config `json:"-"`
	// ID of the ent.
	ID string `json:"id,omitempty"`
	// Name holds the value of the "name" field.
	Name string `json:"name,omitempty"`
	// Region holds the value of the "region" field.
	Region string `json:"region,omitempty"`
	// SurfaceArea holds the value of the "surface_area" field.
	SurfaceArea float64 `json:"surface_area,omitempty"`
	// IndepYear holds the value of the "indep_year" field.
	IndepYear int16 `json:"indep_year,omitempty"`
	// Population holds the value of the "population" field.
	Population int `json:"population,omitempty"`
	// LifeExpectancy holds the value of the "life_expectancy" field.
	LifeExpectancy float64 `json:"life_expectancy,omitempty"`
	// Gnp holds the value of the "gnp" field.
	Gnp float64 `json:"gnp,omitempty"`
	// GnpOld holds the value of the "gnp_old" field.
	GnpOld float64 `json:"gnp_old,omitempty"`
	// LocalName holds the value of the "local_name" field.
	LocalName string `json:"local_name,omitempty"`
	// GovernmentForm holds the value of the "government_form" field.
	GovernmentForm string `json:"government_form,omitempty"`
	// HeadOfState holds the value of the "head_of_state" field.
	HeadOfState *string `json:"head_of_state,omitempty"`
	// Code2 holds the value of the "code2" field.
	Code2 string `json:"code2,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the CountryQuery when eager-loading is set.
	Edges CountryEdges `json:"edges"`
}

// CountryEdges holds the relations/edges for other nodes in the graph.
type CountryEdges struct {
	// Capital holds the value of the capital edge.
	Capital *City `json:"capital,omitempty"`
	// Language holds the value of the language edge.
	Language *Country_language `json:"language,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [2]bool
}

// CapitalOrErr returns the Capital value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e CountryEdges) CapitalOrErr() (*City, error) {
	if e.loadedTypes[0] {
		if e.Capital == nil {
			// The edge capital was loaded in eager-loading,
			// but was not found.
			return nil, &NotFoundError{label: city.Label}
		}
		return e.Capital, nil
	}
	return nil, &NotLoadedError{edge: "capital"}
}

// LanguageOrErr returns the Language value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e CountryEdges) LanguageOrErr() (*Country_language, error) {
	if e.loadedTypes[1] {
		if e.Language == nil {
			// The edge language was loaded in eager-loading,
			// but was not found.
			return nil, &NotFoundError{label: country_language.Label}
		}
		return e.Language, nil
	}
	return nil, &NotLoadedError{edge: "language"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Country) scanValues(columns []string) ([]interface{}, error) {
	values := make([]interface{}, len(columns))
	for i := range columns {
		switch columns[i] {
		case country.FieldSurfaceArea, country.FieldLifeExpectancy, country.FieldGnp, country.FieldGnpOld:
			values[i] = new(sql.NullFloat64)
		case country.FieldIndepYear, country.FieldPopulation:
			values[i] = new(sql.NullInt64)
		case country.FieldID, country.FieldName, country.FieldRegion, country.FieldLocalName, country.FieldGovernmentForm, country.FieldHeadOfState, country.FieldCode2:
			values[i] = new(sql.NullString)
		default:
			return nil, fmt.Errorf("unexpected column %q for type Country", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Country fields.
func (c *Country) assignValues(columns []string, values []interface{}) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case country.FieldID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value.Valid {
				c.ID = value.String
			}
		case country.FieldName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field name", values[i])
			} else if value.Valid {
				c.Name = value.String
			}
		case country.FieldRegion:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field region", values[i])
			} else if value.Valid {
				c.Region = value.String
			}
		case country.FieldSurfaceArea:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field surface_area", values[i])
			} else if value.Valid {
				c.SurfaceArea = value.Float64
			}
		case country.FieldIndepYear:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field indep_year", values[i])
			} else if value.Valid {
				c.IndepYear = int16(value.Int64)
			}
		case country.FieldPopulation:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field population", values[i])
			} else if value.Valid {
				c.Population = int(value.Int64)
			}
		case country.FieldLifeExpectancy:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field life_expectancy", values[i])
			} else if value.Valid {
				c.LifeExpectancy = value.Float64
			}
		case country.FieldGnp:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field gnp", values[i])
			} else if value.Valid {
				c.Gnp = value.Float64
			}
		case country.FieldGnpOld:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field gnp_old", values[i])
			} else if value.Valid {
				c.GnpOld = value.Float64
			}
		case country.FieldLocalName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field local_name", values[i])
			} else if value.Valid {
				c.LocalName = value.String
			}
		case country.FieldGovernmentForm:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field government_form", values[i])
			} else if value.Valid {
				c.GovernmentForm = value.String
			}
		case country.FieldHeadOfState:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field head_of_state", values[i])
			} else if value.Valid {
				c.HeadOfState = new(string)
				*c.HeadOfState = value.String
			}
		case country.FieldCode2:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field code2", values[i])
			} else if value.Valid {
				c.Code2 = value.String
			}
		}
	}
	return nil
}

// QueryCapital queries the "capital" edge of the Country entity.
func (c *Country) QueryCapital() *CityQuery {
	return (&CountryClient{config: c.config}).QueryCapital(c)
}

// QueryLanguage queries the "language" edge of the Country entity.
func (c *Country) QueryLanguage() *CountryLanguageQuery {
	return (&CountryClient{config: c.config}).QueryLanguage(c)
}

// Update returns a builder for updating this Country.
// Note that you need to call Country.Unwrap() before calling this method if this Country
// was returned from a transaction, and the transaction was committed or rolled back.
func (c *Country) Update() *CountryUpdateOne {
	return (&CountryClient{config: c.config}).UpdateOne(c)
}

// Unwrap unwraps the Country entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (c *Country) Unwrap() *Country {
	tx, ok := c.config.driver.(*txDriver)
	if !ok {
		panic("ent: Country is not a transactional entity")
	}
	c.config.driver = tx.drv
	return c
}

// String implements the fmt.Stringer.
func (c *Country) String() string {
	var builder strings.Builder
	builder.WriteString("Country(")
	builder.WriteString(fmt.Sprintf("id=%v", c.ID))
	builder.WriteString(", name=")
	builder.WriteString(c.Name)
	builder.WriteString(", region=")
	builder.WriteString(c.Region)
	builder.WriteString(", surface_area=")
	builder.WriteString(fmt.Sprintf("%v", c.SurfaceArea))
	builder.WriteString(", indep_year=")
	builder.WriteString(fmt.Sprintf("%v", c.IndepYear))
	builder.WriteString(", population=")
	builder.WriteString(fmt.Sprintf("%v", c.Population))
	builder.WriteString(", life_expectancy=")
	builder.WriteString(fmt.Sprintf("%v", c.LifeExpectancy))
	builder.WriteString(", gnp=")
	builder.WriteString(fmt.Sprintf("%v", c.Gnp))
	builder.WriteString(", gnp_old=")
	builder.WriteString(fmt.Sprintf("%v", c.GnpOld))
	builder.WriteString(", local_name=")
	builder.WriteString(c.LocalName)
	builder.WriteString(", government_form=")
	builder.WriteString(c.GovernmentForm)
	if v := c.HeadOfState; v != nil {
		builder.WriteString(", head_of_state=")
		builder.WriteString(*v)
	}
	builder.WriteString(", code2=")
	builder.WriteString(c.Code2)
	builder.WriteByte(')')
	return builder.String()
}

// Countries is a parsable slice of Country.
type Countries []*Country

func (c Countries) config(cfg config) {
	for _i := range c {
		c[_i].config = cfg
	}
}
