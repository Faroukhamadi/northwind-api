// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"github.com/Faroukhamadi/northwind-api/ent/city"
	"github.com/Faroukhamadi/northwind-api/ent/country"
	"github.com/Faroukhamadi/northwind-api/ent/country_language"
	"github.com/Faroukhamadi/northwind-api/ent/predicate"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCity             = "City"
	TypeCountry          = "Country"
	TypeCountry_language = "Country_language"
)

// CityMutation represents an operation that mutates the City nodes in the graph.
type CityMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	district       *string
	population     *int
	addpopulation  *int
	clearedFields  map[string]struct{}
	country        *string
	clearedcountry bool
	done           bool
	oldValue       func(context.Context) (*City, error)
	predicates     []predicate.City
}

var _ ent.Mutation = (*CityMutation)(nil)

// cityOption allows management of the mutation configuration using functional options.
type cityOption func(*CityMutation)

// newCityMutation creates new mutation for the City entity.
func newCityMutation(c config, op Op, opts ...cityOption) *CityMutation {
	m := &CityMutation{
		config:        c,
		op:            op,
		typ:           TypeCity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCityID sets the ID field of the mutation.
func withCityID(id int) cityOption {
	return func(m *CityMutation) {
		var (
			err   error
			once  sync.Once
			value *City
		)
		m.oldValue = func(ctx context.Context) (*City, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().City.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCity sets the old City of the mutation.
func withCity(node *City) cityOption {
	return func(m *CityMutation) {
		m.oldValue = func(context.Context) (*City, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CityMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().City.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CityMutation) ResetName() {
	m.name = nil
}

// SetDistrict sets the "district" field.
func (m *CityMutation) SetDistrict(s string) {
	m.district = &s
}

// District returns the value of the "district" field in the mutation.
func (m *CityMutation) District() (r string, exists bool) {
	v := m.district
	if v == nil {
		return
	}
	return *v, true
}

// OldDistrict returns the old "district" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldDistrict(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDistrict is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDistrict requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistrict: %w", err)
	}
	return oldValue.District, nil
}

// ResetDistrict resets all changes to the "district" field.
func (m *CityMutation) ResetDistrict() {
	m.district = nil
}

// SetPopulation sets the "population" field.
func (m *CityMutation) SetPopulation(i int) {
	m.population = &i
	m.addpopulation = nil
}

// Population returns the value of the "population" field in the mutation.
func (m *CityMutation) Population() (r int, exists bool) {
	v := m.population
	if v == nil {
		return
	}
	return *v, true
}

// OldPopulation returns the old "population" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldPopulation(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPopulation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPopulation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPopulation: %w", err)
	}
	return oldValue.Population, nil
}

// AddPopulation adds i to the "population" field.
func (m *CityMutation) AddPopulation(i int) {
	if m.addpopulation != nil {
		*m.addpopulation += i
	} else {
		m.addpopulation = &i
	}
}

// AddedPopulation returns the value that was added to the "population" field in this mutation.
func (m *CityMutation) AddedPopulation() (r int, exists bool) {
	v := m.addpopulation
	if v == nil {
		return
	}
	return *v, true
}

// ResetPopulation resets all changes to the "population" field.
func (m *CityMutation) ResetPopulation() {
	m.population = nil
	m.addpopulation = nil
}

// SetCountryID sets the "country" edge to the Country entity by id.
func (m *CityMutation) SetCountryID(id string) {
	m.country = &id
}

// ClearCountry clears the "country" edge to the Country entity.
func (m *CityMutation) ClearCountry() {
	m.clearedcountry = true
}

// CountryCleared reports if the "country" edge to the Country entity was cleared.
func (m *CityMutation) CountryCleared() bool {
	return m.clearedcountry
}

// CountryID returns the "country" edge ID in the mutation.
func (m *CityMutation) CountryID() (id string, exists bool) {
	if m.country != nil {
		return *m.country, true
	}
	return
}

// CountryIDs returns the "country" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CountryID instead. It exists only for internal usage by the builders.
func (m *CityMutation) CountryIDs() (ids []string) {
	if id := m.country; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCountry resets all changes to the "country" edge.
func (m *CityMutation) ResetCountry() {
	m.country = nil
	m.clearedcountry = false
}

// Where appends a list predicates to the CityMutation builder.
func (m *CityMutation) Where(ps ...predicate.City) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (City).
func (m *CityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CityMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, city.FieldName)
	}
	if m.district != nil {
		fields = append(fields, city.FieldDistrict)
	}
	if m.population != nil {
		fields = append(fields, city.FieldPopulation)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case city.FieldName:
		return m.Name()
	case city.FieldDistrict:
		return m.District()
	case city.FieldPopulation:
		return m.Population()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case city.FieldName:
		return m.OldName(ctx)
	case city.FieldDistrict:
		return m.OldDistrict(ctx)
	case city.FieldPopulation:
		return m.OldPopulation(ctx)
	}
	return nil, fmt.Errorf("unknown City field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case city.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case city.FieldDistrict:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistrict(v)
		return nil
	case city.FieldPopulation:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPopulation(v)
		return nil
	}
	return fmt.Errorf("unknown City field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CityMutation) AddedFields() []string {
	var fields []string
	if m.addpopulation != nil {
		fields = append(fields, city.FieldPopulation)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case city.FieldPopulation:
		return m.AddedPopulation()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case city.FieldPopulation:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPopulation(v)
		return nil
	}
	return fmt.Errorf("unknown City numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown City nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CityMutation) ResetField(name string) error {
	switch name {
	case city.FieldName:
		m.ResetName()
		return nil
	case city.FieldDistrict:
		m.ResetDistrict()
		return nil
	case city.FieldPopulation:
		m.ResetPopulation()
		return nil
	}
	return fmt.Errorf("unknown City field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CityMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.country != nil {
		edges = append(edges, city.EdgeCountry)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case city.EdgeCountry:
		if id := m.country; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcountry {
		edges = append(edges, city.EdgeCountry)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CityMutation) EdgeCleared(name string) bool {
	switch name {
	case city.EdgeCountry:
		return m.clearedcountry
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CityMutation) ClearEdge(name string) error {
	switch name {
	case city.EdgeCountry:
		m.ClearCountry()
		return nil
	}
	return fmt.Errorf("unknown City unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CityMutation) ResetEdge(name string) error {
	switch name {
	case city.EdgeCountry:
		m.ResetCountry()
		return nil
	}
	return fmt.Errorf("unknown City edge %s", name)
}

// CountryMutation represents an operation that mutates the Country nodes in the graph.
type CountryMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	name               *string
	region             *string
	surface_area       *float64
	addsurface_area    *float64
	indep_year         *int16
	addindep_year      *int16
	population         *int
	addpopulation      *int
	life_expectancy    *float64
	addlife_expectancy *float64
	gnp                *float64
	addgnp             *float64
	gnp_old            *float64
	addgnp_old         *float64
	local_name         *string
	government_form    *string
	head_of_state      *string
	code2              *string
	clearedFields      map[string]struct{}
	capital            *int
	clearedcapital     bool
	language           *int
	clearedlanguage    bool
	done               bool
	oldValue           func(context.Context) (*Country, error)
	predicates         []predicate.Country
}

var _ ent.Mutation = (*CountryMutation)(nil)

// countryOption allows management of the mutation configuration using functional options.
type countryOption func(*CountryMutation)

// newCountryMutation creates new mutation for the Country entity.
func newCountryMutation(c config, op Op, opts ...countryOption) *CountryMutation {
	m := &CountryMutation{
		config:        c,
		op:            op,
		typ:           TypeCountry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCountryID sets the ID field of the mutation.
func withCountryID(id string) countryOption {
	return func(m *CountryMutation) {
		var (
			err   error
			once  sync.Once
			value *Country
		)
		m.oldValue = func(ctx context.Context) (*Country, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Country.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCountry sets the old Country of the mutation.
func withCountry(node *Country) countryOption {
	return func(m *CountryMutation) {
		m.oldValue = func(context.Context) (*Country, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CountryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CountryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Country entities.
func (m *CountryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CountryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CountryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Country.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CountryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CountryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CountryMutation) ResetName() {
	m.name = nil
}

// SetRegion sets the "region" field.
func (m *CountryMutation) SetRegion(s string) {
	m.region = &s
}

// Region returns the value of the "region" field in the mutation.
func (m *CountryMutation) Region() (r string, exists bool) {
	v := m.region
	if v == nil {
		return
	}
	return *v, true
}

// OldRegion returns the old "region" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldRegion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegion: %w", err)
	}
	return oldValue.Region, nil
}

// ResetRegion resets all changes to the "region" field.
func (m *CountryMutation) ResetRegion() {
	m.region = nil
}

// SetSurfaceArea sets the "surface_area" field.
func (m *CountryMutation) SetSurfaceArea(f float64) {
	m.surface_area = &f
	m.addsurface_area = nil
}

// SurfaceArea returns the value of the "surface_area" field in the mutation.
func (m *CountryMutation) SurfaceArea() (r float64, exists bool) {
	v := m.surface_area
	if v == nil {
		return
	}
	return *v, true
}

// OldSurfaceArea returns the old "surface_area" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldSurfaceArea(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSurfaceArea is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSurfaceArea requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSurfaceArea: %w", err)
	}
	return oldValue.SurfaceArea, nil
}

// AddSurfaceArea adds f to the "surface_area" field.
func (m *CountryMutation) AddSurfaceArea(f float64) {
	if m.addsurface_area != nil {
		*m.addsurface_area += f
	} else {
		m.addsurface_area = &f
	}
}

// AddedSurfaceArea returns the value that was added to the "surface_area" field in this mutation.
func (m *CountryMutation) AddedSurfaceArea() (r float64, exists bool) {
	v := m.addsurface_area
	if v == nil {
		return
	}
	return *v, true
}

// ResetSurfaceArea resets all changes to the "surface_area" field.
func (m *CountryMutation) ResetSurfaceArea() {
	m.surface_area = nil
	m.addsurface_area = nil
}

// SetIndepYear sets the "indep_year" field.
func (m *CountryMutation) SetIndepYear(i int16) {
	m.indep_year = &i
	m.addindep_year = nil
}

// IndepYear returns the value of the "indep_year" field in the mutation.
func (m *CountryMutation) IndepYear() (r int16, exists bool) {
	v := m.indep_year
	if v == nil {
		return
	}
	return *v, true
}

// OldIndepYear returns the old "indep_year" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldIndepYear(ctx context.Context) (v int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndepYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndepYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndepYear: %w", err)
	}
	return oldValue.IndepYear, nil
}

// AddIndepYear adds i to the "indep_year" field.
func (m *CountryMutation) AddIndepYear(i int16) {
	if m.addindep_year != nil {
		*m.addindep_year += i
	} else {
		m.addindep_year = &i
	}
}

// AddedIndepYear returns the value that was added to the "indep_year" field in this mutation.
func (m *CountryMutation) AddedIndepYear() (r int16, exists bool) {
	v := m.addindep_year
	if v == nil {
		return
	}
	return *v, true
}

// ResetIndepYear resets all changes to the "indep_year" field.
func (m *CountryMutation) ResetIndepYear() {
	m.indep_year = nil
	m.addindep_year = nil
}

// SetPopulation sets the "population" field.
func (m *CountryMutation) SetPopulation(i int) {
	m.population = &i
	m.addpopulation = nil
}

// Population returns the value of the "population" field in the mutation.
func (m *CountryMutation) Population() (r int, exists bool) {
	v := m.population
	if v == nil {
		return
	}
	return *v, true
}

// OldPopulation returns the old "population" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldPopulation(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPopulation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPopulation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPopulation: %w", err)
	}
	return oldValue.Population, nil
}

// AddPopulation adds i to the "population" field.
func (m *CountryMutation) AddPopulation(i int) {
	if m.addpopulation != nil {
		*m.addpopulation += i
	} else {
		m.addpopulation = &i
	}
}

// AddedPopulation returns the value that was added to the "population" field in this mutation.
func (m *CountryMutation) AddedPopulation() (r int, exists bool) {
	v := m.addpopulation
	if v == nil {
		return
	}
	return *v, true
}

// ResetPopulation resets all changes to the "population" field.
func (m *CountryMutation) ResetPopulation() {
	m.population = nil
	m.addpopulation = nil
}

// SetLifeExpectancy sets the "life_expectancy" field.
func (m *CountryMutation) SetLifeExpectancy(f float64) {
	m.life_expectancy = &f
	m.addlife_expectancy = nil
}

// LifeExpectancy returns the value of the "life_expectancy" field in the mutation.
func (m *CountryMutation) LifeExpectancy() (r float64, exists bool) {
	v := m.life_expectancy
	if v == nil {
		return
	}
	return *v, true
}

// OldLifeExpectancy returns the old "life_expectancy" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldLifeExpectancy(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLifeExpectancy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLifeExpectancy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLifeExpectancy: %w", err)
	}
	return oldValue.LifeExpectancy, nil
}

// AddLifeExpectancy adds f to the "life_expectancy" field.
func (m *CountryMutation) AddLifeExpectancy(f float64) {
	if m.addlife_expectancy != nil {
		*m.addlife_expectancy += f
	} else {
		m.addlife_expectancy = &f
	}
}

// AddedLifeExpectancy returns the value that was added to the "life_expectancy" field in this mutation.
func (m *CountryMutation) AddedLifeExpectancy() (r float64, exists bool) {
	v := m.addlife_expectancy
	if v == nil {
		return
	}
	return *v, true
}

// ResetLifeExpectancy resets all changes to the "life_expectancy" field.
func (m *CountryMutation) ResetLifeExpectancy() {
	m.life_expectancy = nil
	m.addlife_expectancy = nil
}

// SetGnp sets the "gnp" field.
func (m *CountryMutation) SetGnp(f float64) {
	m.gnp = &f
	m.addgnp = nil
}

// Gnp returns the value of the "gnp" field in the mutation.
func (m *CountryMutation) Gnp() (r float64, exists bool) {
	v := m.gnp
	if v == nil {
		return
	}
	return *v, true
}

// OldGnp returns the old "gnp" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldGnp(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGnp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGnp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGnp: %w", err)
	}
	return oldValue.Gnp, nil
}

// AddGnp adds f to the "gnp" field.
func (m *CountryMutation) AddGnp(f float64) {
	if m.addgnp != nil {
		*m.addgnp += f
	} else {
		m.addgnp = &f
	}
}

// AddedGnp returns the value that was added to the "gnp" field in this mutation.
func (m *CountryMutation) AddedGnp() (r float64, exists bool) {
	v := m.addgnp
	if v == nil {
		return
	}
	return *v, true
}

// ResetGnp resets all changes to the "gnp" field.
func (m *CountryMutation) ResetGnp() {
	m.gnp = nil
	m.addgnp = nil
}

// SetGnpOld sets the "gnp_old" field.
func (m *CountryMutation) SetGnpOld(f float64) {
	m.gnp_old = &f
	m.addgnp_old = nil
}

// GnpOld returns the value of the "gnp_old" field in the mutation.
func (m *CountryMutation) GnpOld() (r float64, exists bool) {
	v := m.gnp_old
	if v == nil {
		return
	}
	return *v, true
}

// OldGnpOld returns the old "gnp_old" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldGnpOld(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGnpOld is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGnpOld requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGnpOld: %w", err)
	}
	return oldValue.GnpOld, nil
}

// AddGnpOld adds f to the "gnp_old" field.
func (m *CountryMutation) AddGnpOld(f float64) {
	if m.addgnp_old != nil {
		*m.addgnp_old += f
	} else {
		m.addgnp_old = &f
	}
}

// AddedGnpOld returns the value that was added to the "gnp_old" field in this mutation.
func (m *CountryMutation) AddedGnpOld() (r float64, exists bool) {
	v := m.addgnp_old
	if v == nil {
		return
	}
	return *v, true
}

// ResetGnpOld resets all changes to the "gnp_old" field.
func (m *CountryMutation) ResetGnpOld() {
	m.gnp_old = nil
	m.addgnp_old = nil
}

// SetLocalName sets the "local_name" field.
func (m *CountryMutation) SetLocalName(s string) {
	m.local_name = &s
}

// LocalName returns the value of the "local_name" field in the mutation.
func (m *CountryMutation) LocalName() (r string, exists bool) {
	v := m.local_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalName returns the old "local_name" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldLocalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalName: %w", err)
	}
	return oldValue.LocalName, nil
}

// ResetLocalName resets all changes to the "local_name" field.
func (m *CountryMutation) ResetLocalName() {
	m.local_name = nil
}

// SetGovernmentForm sets the "government_form" field.
func (m *CountryMutation) SetGovernmentForm(s string) {
	m.government_form = &s
}

// GovernmentForm returns the value of the "government_form" field in the mutation.
func (m *CountryMutation) GovernmentForm() (r string, exists bool) {
	v := m.government_form
	if v == nil {
		return
	}
	return *v, true
}

// OldGovernmentForm returns the old "government_form" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldGovernmentForm(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGovernmentForm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGovernmentForm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGovernmentForm: %w", err)
	}
	return oldValue.GovernmentForm, nil
}

// ResetGovernmentForm resets all changes to the "government_form" field.
func (m *CountryMutation) ResetGovernmentForm() {
	m.government_form = nil
}

// SetHeadOfState sets the "head_of_state" field.
func (m *CountryMutation) SetHeadOfState(s string) {
	m.head_of_state = &s
}

// HeadOfState returns the value of the "head_of_state" field in the mutation.
func (m *CountryMutation) HeadOfState() (r string, exists bool) {
	v := m.head_of_state
	if v == nil {
		return
	}
	return *v, true
}

// OldHeadOfState returns the old "head_of_state" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldHeadOfState(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeadOfState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeadOfState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeadOfState: %w", err)
	}
	return oldValue.HeadOfState, nil
}

// ClearHeadOfState clears the value of the "head_of_state" field.
func (m *CountryMutation) ClearHeadOfState() {
	m.head_of_state = nil
	m.clearedFields[country.FieldHeadOfState] = struct{}{}
}

// HeadOfStateCleared returns if the "head_of_state" field was cleared in this mutation.
func (m *CountryMutation) HeadOfStateCleared() bool {
	_, ok := m.clearedFields[country.FieldHeadOfState]
	return ok
}

// ResetHeadOfState resets all changes to the "head_of_state" field.
func (m *CountryMutation) ResetHeadOfState() {
	m.head_of_state = nil
	delete(m.clearedFields, country.FieldHeadOfState)
}

// SetCode2 sets the "code2" field.
func (m *CountryMutation) SetCode2(s string) {
	m.code2 = &s
}

// Code2 returns the value of the "code2" field in the mutation.
func (m *CountryMutation) Code2() (r string, exists bool) {
	v := m.code2
	if v == nil {
		return
	}
	return *v, true
}

// OldCode2 returns the old "code2" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldCode2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode2: %w", err)
	}
	return oldValue.Code2, nil
}

// ResetCode2 resets all changes to the "code2" field.
func (m *CountryMutation) ResetCode2() {
	m.code2 = nil
}

// SetCapitalID sets the "capital" edge to the City entity by id.
func (m *CountryMutation) SetCapitalID(id int) {
	m.capital = &id
}

// ClearCapital clears the "capital" edge to the City entity.
func (m *CountryMutation) ClearCapital() {
	m.clearedcapital = true
}

// CapitalCleared reports if the "capital" edge to the City entity was cleared.
func (m *CountryMutation) CapitalCleared() bool {
	return m.clearedcapital
}

// CapitalID returns the "capital" edge ID in the mutation.
func (m *CountryMutation) CapitalID() (id int, exists bool) {
	if m.capital != nil {
		return *m.capital, true
	}
	return
}

// CapitalIDs returns the "capital" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CapitalID instead. It exists only for internal usage by the builders.
func (m *CountryMutation) CapitalIDs() (ids []int) {
	if id := m.capital; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCapital resets all changes to the "capital" edge.
func (m *CountryMutation) ResetCapital() {
	m.capital = nil
	m.clearedcapital = false
}

// SetLanguageID sets the "language" edge to the Country_language entity by id.
func (m *CountryMutation) SetLanguageID(id int) {
	m.language = &id
}

// ClearLanguage clears the "language" edge to the Country_language entity.
func (m *CountryMutation) ClearLanguage() {
	m.clearedlanguage = true
}

// LanguageCleared reports if the "language" edge to the Country_language entity was cleared.
func (m *CountryMutation) LanguageCleared() bool {
	return m.clearedlanguage
}

// LanguageID returns the "language" edge ID in the mutation.
func (m *CountryMutation) LanguageID() (id int, exists bool) {
	if m.language != nil {
		return *m.language, true
	}
	return
}

// LanguageIDs returns the "language" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LanguageID instead. It exists only for internal usage by the builders.
func (m *CountryMutation) LanguageIDs() (ids []int) {
	if id := m.language; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLanguage resets all changes to the "language" edge.
func (m *CountryMutation) ResetLanguage() {
	m.language = nil
	m.clearedlanguage = false
}

// Where appends a list predicates to the CountryMutation builder.
func (m *CountryMutation) Where(ps ...predicate.Country) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CountryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Country).
func (m *CountryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CountryMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.name != nil {
		fields = append(fields, country.FieldName)
	}
	if m.region != nil {
		fields = append(fields, country.FieldRegion)
	}
	if m.surface_area != nil {
		fields = append(fields, country.FieldSurfaceArea)
	}
	if m.indep_year != nil {
		fields = append(fields, country.FieldIndepYear)
	}
	if m.population != nil {
		fields = append(fields, country.FieldPopulation)
	}
	if m.life_expectancy != nil {
		fields = append(fields, country.FieldLifeExpectancy)
	}
	if m.gnp != nil {
		fields = append(fields, country.FieldGnp)
	}
	if m.gnp_old != nil {
		fields = append(fields, country.FieldGnpOld)
	}
	if m.local_name != nil {
		fields = append(fields, country.FieldLocalName)
	}
	if m.government_form != nil {
		fields = append(fields, country.FieldGovernmentForm)
	}
	if m.head_of_state != nil {
		fields = append(fields, country.FieldHeadOfState)
	}
	if m.code2 != nil {
		fields = append(fields, country.FieldCode2)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CountryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case country.FieldName:
		return m.Name()
	case country.FieldRegion:
		return m.Region()
	case country.FieldSurfaceArea:
		return m.SurfaceArea()
	case country.FieldIndepYear:
		return m.IndepYear()
	case country.FieldPopulation:
		return m.Population()
	case country.FieldLifeExpectancy:
		return m.LifeExpectancy()
	case country.FieldGnp:
		return m.Gnp()
	case country.FieldGnpOld:
		return m.GnpOld()
	case country.FieldLocalName:
		return m.LocalName()
	case country.FieldGovernmentForm:
		return m.GovernmentForm()
	case country.FieldHeadOfState:
		return m.HeadOfState()
	case country.FieldCode2:
		return m.Code2()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CountryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case country.FieldName:
		return m.OldName(ctx)
	case country.FieldRegion:
		return m.OldRegion(ctx)
	case country.FieldSurfaceArea:
		return m.OldSurfaceArea(ctx)
	case country.FieldIndepYear:
		return m.OldIndepYear(ctx)
	case country.FieldPopulation:
		return m.OldPopulation(ctx)
	case country.FieldLifeExpectancy:
		return m.OldLifeExpectancy(ctx)
	case country.FieldGnp:
		return m.OldGnp(ctx)
	case country.FieldGnpOld:
		return m.OldGnpOld(ctx)
	case country.FieldLocalName:
		return m.OldLocalName(ctx)
	case country.FieldGovernmentForm:
		return m.OldGovernmentForm(ctx)
	case country.FieldHeadOfState:
		return m.OldHeadOfState(ctx)
	case country.FieldCode2:
		return m.OldCode2(ctx)
	}
	return nil, fmt.Errorf("unknown Country field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CountryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case country.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case country.FieldRegion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegion(v)
		return nil
	case country.FieldSurfaceArea:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSurfaceArea(v)
		return nil
	case country.FieldIndepYear:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndepYear(v)
		return nil
	case country.FieldPopulation:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPopulation(v)
		return nil
	case country.FieldLifeExpectancy:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLifeExpectancy(v)
		return nil
	case country.FieldGnp:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGnp(v)
		return nil
	case country.FieldGnpOld:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGnpOld(v)
		return nil
	case country.FieldLocalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalName(v)
		return nil
	case country.FieldGovernmentForm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGovernmentForm(v)
		return nil
	case country.FieldHeadOfState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeadOfState(v)
		return nil
	case country.FieldCode2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode2(v)
		return nil
	}
	return fmt.Errorf("unknown Country field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CountryMutation) AddedFields() []string {
	var fields []string
	if m.addsurface_area != nil {
		fields = append(fields, country.FieldSurfaceArea)
	}
	if m.addindep_year != nil {
		fields = append(fields, country.FieldIndepYear)
	}
	if m.addpopulation != nil {
		fields = append(fields, country.FieldPopulation)
	}
	if m.addlife_expectancy != nil {
		fields = append(fields, country.FieldLifeExpectancy)
	}
	if m.addgnp != nil {
		fields = append(fields, country.FieldGnp)
	}
	if m.addgnp_old != nil {
		fields = append(fields, country.FieldGnpOld)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CountryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case country.FieldSurfaceArea:
		return m.AddedSurfaceArea()
	case country.FieldIndepYear:
		return m.AddedIndepYear()
	case country.FieldPopulation:
		return m.AddedPopulation()
	case country.FieldLifeExpectancy:
		return m.AddedLifeExpectancy()
	case country.FieldGnp:
		return m.AddedGnp()
	case country.FieldGnpOld:
		return m.AddedGnpOld()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CountryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case country.FieldSurfaceArea:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSurfaceArea(v)
		return nil
	case country.FieldIndepYear:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndepYear(v)
		return nil
	case country.FieldPopulation:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPopulation(v)
		return nil
	case country.FieldLifeExpectancy:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLifeExpectancy(v)
		return nil
	case country.FieldGnp:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGnp(v)
		return nil
	case country.FieldGnpOld:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGnpOld(v)
		return nil
	}
	return fmt.Errorf("unknown Country numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CountryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(country.FieldHeadOfState) {
		fields = append(fields, country.FieldHeadOfState)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CountryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CountryMutation) ClearField(name string) error {
	switch name {
	case country.FieldHeadOfState:
		m.ClearHeadOfState()
		return nil
	}
	return fmt.Errorf("unknown Country nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CountryMutation) ResetField(name string) error {
	switch name {
	case country.FieldName:
		m.ResetName()
		return nil
	case country.FieldRegion:
		m.ResetRegion()
		return nil
	case country.FieldSurfaceArea:
		m.ResetSurfaceArea()
		return nil
	case country.FieldIndepYear:
		m.ResetIndepYear()
		return nil
	case country.FieldPopulation:
		m.ResetPopulation()
		return nil
	case country.FieldLifeExpectancy:
		m.ResetLifeExpectancy()
		return nil
	case country.FieldGnp:
		m.ResetGnp()
		return nil
	case country.FieldGnpOld:
		m.ResetGnpOld()
		return nil
	case country.FieldLocalName:
		m.ResetLocalName()
		return nil
	case country.FieldGovernmentForm:
		m.ResetGovernmentForm()
		return nil
	case country.FieldHeadOfState:
		m.ResetHeadOfState()
		return nil
	case country.FieldCode2:
		m.ResetCode2()
		return nil
	}
	return fmt.Errorf("unknown Country field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CountryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.capital != nil {
		edges = append(edges, country.EdgeCapital)
	}
	if m.language != nil {
		edges = append(edges, country.EdgeLanguage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CountryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case country.EdgeCapital:
		if id := m.capital; id != nil {
			return []ent.Value{*id}
		}
	case country.EdgeLanguage:
		if id := m.language; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CountryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CountryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CountryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcapital {
		edges = append(edges, country.EdgeCapital)
	}
	if m.clearedlanguage {
		edges = append(edges, country.EdgeLanguage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CountryMutation) EdgeCleared(name string) bool {
	switch name {
	case country.EdgeCapital:
		return m.clearedcapital
	case country.EdgeLanguage:
		return m.clearedlanguage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CountryMutation) ClearEdge(name string) error {
	switch name {
	case country.EdgeCapital:
		m.ClearCapital()
		return nil
	case country.EdgeLanguage:
		m.ClearLanguage()
		return nil
	}
	return fmt.Errorf("unknown Country unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CountryMutation) ResetEdge(name string) error {
	switch name {
	case country.EdgeCapital:
		m.ResetCapital()
		return nil
	case country.EdgeLanguage:
		m.ResetLanguage()
		return nil
	}
	return fmt.Errorf("unknown Country edge %s", name)
}

// CountryLanguageMutation represents an operation that mutates the Country_language nodes in the graph.
type CountryLanguageMutation struct {
	config
	op             Op
	typ            string
	id             *int
	country_code   *string
	language       *string
	is_official    *bool
	percentage     *float64
	addpercentage  *float64
	clearedFields  map[string]struct{}
	country        *string
	clearedcountry bool
	done           bool
	oldValue       func(context.Context) (*Country_language, error)
	predicates     []predicate.Country_language
}

var _ ent.Mutation = (*CountryLanguageMutation)(nil)

// countryLanguageOption allows management of the mutation configuration using functional options.
type countryLanguageOption func(*CountryLanguageMutation)

// newCountryLanguageMutation creates new mutation for the Country_language entity.
func newCountryLanguageMutation(c config, op Op, opts ...countryLanguageOption) *CountryLanguageMutation {
	m := &CountryLanguageMutation{
		config:        c,
		op:            op,
		typ:           TypeCountry_language,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCountry_languageID sets the ID field of the mutation.
func withCountry_languageID(id int) countryLanguageOption {
	return func(m *CountryLanguageMutation) {
		var (
			err   error
			once  sync.Once
			value *Country_language
		)
		m.oldValue = func(ctx context.Context) (*Country_language, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Country_language.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCountry_language sets the old Country_language of the mutation.
func withCountry_language(node *Country_language) countryLanguageOption {
	return func(m *CountryLanguageMutation) {
		m.oldValue = func(context.Context) (*Country_language, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CountryLanguageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CountryLanguageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CountryLanguageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CountryLanguageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Country_language.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCountryCode sets the "country_code" field.
func (m *CountryLanguageMutation) SetCountryCode(s string) {
	m.country_code = &s
}

// CountryCode returns the value of the "country_code" field in the mutation.
func (m *CountryLanguageMutation) CountryCode() (r string, exists bool) {
	v := m.country_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryCode returns the old "country_code" field's value of the Country_language entity.
// If the Country_language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryLanguageMutation) OldCountryCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryCode: %w", err)
	}
	return oldValue.CountryCode, nil
}

// ResetCountryCode resets all changes to the "country_code" field.
func (m *CountryLanguageMutation) ResetCountryCode() {
	m.country_code = nil
}

// SetLanguage sets the "language" field.
func (m *CountryLanguageMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *CountryLanguageMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the Country_language entity.
// If the Country_language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryLanguageMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ResetLanguage resets all changes to the "language" field.
func (m *CountryLanguageMutation) ResetLanguage() {
	m.language = nil
}

// SetIsOfficial sets the "is_official" field.
func (m *CountryLanguageMutation) SetIsOfficial(b bool) {
	m.is_official = &b
}

// IsOfficial returns the value of the "is_official" field in the mutation.
func (m *CountryLanguageMutation) IsOfficial() (r bool, exists bool) {
	v := m.is_official
	if v == nil {
		return
	}
	return *v, true
}

// OldIsOfficial returns the old "is_official" field's value of the Country_language entity.
// If the Country_language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryLanguageMutation) OldIsOfficial(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsOfficial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsOfficial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsOfficial: %w", err)
	}
	return oldValue.IsOfficial, nil
}

// ResetIsOfficial resets all changes to the "is_official" field.
func (m *CountryLanguageMutation) ResetIsOfficial() {
	m.is_official = nil
}

// SetPercentage sets the "percentage" field.
func (m *CountryLanguageMutation) SetPercentage(f float64) {
	m.percentage = &f
	m.addpercentage = nil
}

// Percentage returns the value of the "percentage" field in the mutation.
func (m *CountryLanguageMutation) Percentage() (r float64, exists bool) {
	v := m.percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldPercentage returns the old "percentage" field's value of the Country_language entity.
// If the Country_language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryLanguageMutation) OldPercentage(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPercentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPercentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPercentage: %w", err)
	}
	return oldValue.Percentage, nil
}

// AddPercentage adds f to the "percentage" field.
func (m *CountryLanguageMutation) AddPercentage(f float64) {
	if m.addpercentage != nil {
		*m.addpercentage += f
	} else {
		m.addpercentage = &f
	}
}

// AddedPercentage returns the value that was added to the "percentage" field in this mutation.
func (m *CountryLanguageMutation) AddedPercentage() (r float64, exists bool) {
	v := m.addpercentage
	if v == nil {
		return
	}
	return *v, true
}

// ResetPercentage resets all changes to the "percentage" field.
func (m *CountryLanguageMutation) ResetPercentage() {
	m.percentage = nil
	m.addpercentage = nil
}

// SetCountryID sets the "country" edge to the Country entity by id.
func (m *CountryLanguageMutation) SetCountryID(id string) {
	m.country = &id
}

// ClearCountry clears the "country" edge to the Country entity.
func (m *CountryLanguageMutation) ClearCountry() {
	m.clearedcountry = true
}

// CountryCleared reports if the "country" edge to the Country entity was cleared.
func (m *CountryLanguageMutation) CountryCleared() bool {
	return m.clearedcountry
}

// CountryID returns the "country" edge ID in the mutation.
func (m *CountryLanguageMutation) CountryID() (id string, exists bool) {
	if m.country != nil {
		return *m.country, true
	}
	return
}

// CountryIDs returns the "country" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CountryID instead. It exists only for internal usage by the builders.
func (m *CountryLanguageMutation) CountryIDs() (ids []string) {
	if id := m.country; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCountry resets all changes to the "country" edge.
func (m *CountryLanguageMutation) ResetCountry() {
	m.country = nil
	m.clearedcountry = false
}

// Where appends a list predicates to the CountryLanguageMutation builder.
func (m *CountryLanguageMutation) Where(ps ...predicate.Country_language) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CountryLanguageMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Country_language).
func (m *CountryLanguageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CountryLanguageMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.country_code != nil {
		fields = append(fields, country_language.FieldCountryCode)
	}
	if m.language != nil {
		fields = append(fields, country_language.FieldLanguage)
	}
	if m.is_official != nil {
		fields = append(fields, country_language.FieldIsOfficial)
	}
	if m.percentage != nil {
		fields = append(fields, country_language.FieldPercentage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CountryLanguageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case country_language.FieldCountryCode:
		return m.CountryCode()
	case country_language.FieldLanguage:
		return m.Language()
	case country_language.FieldIsOfficial:
		return m.IsOfficial()
	case country_language.FieldPercentage:
		return m.Percentage()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CountryLanguageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case country_language.FieldCountryCode:
		return m.OldCountryCode(ctx)
	case country_language.FieldLanguage:
		return m.OldLanguage(ctx)
	case country_language.FieldIsOfficial:
		return m.OldIsOfficial(ctx)
	case country_language.FieldPercentage:
		return m.OldPercentage(ctx)
	}
	return nil, fmt.Errorf("unknown Country_language field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CountryLanguageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case country_language.FieldCountryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryCode(v)
		return nil
	case country_language.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case country_language.FieldIsOfficial:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsOfficial(v)
		return nil
	case country_language.FieldPercentage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPercentage(v)
		return nil
	}
	return fmt.Errorf("unknown Country_language field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CountryLanguageMutation) AddedFields() []string {
	var fields []string
	if m.addpercentage != nil {
		fields = append(fields, country_language.FieldPercentage)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CountryLanguageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case country_language.FieldPercentage:
		return m.AddedPercentage()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CountryLanguageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case country_language.FieldPercentage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPercentage(v)
		return nil
	}
	return fmt.Errorf("unknown Country_language numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CountryLanguageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CountryLanguageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CountryLanguageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Country_language nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CountryLanguageMutation) ResetField(name string) error {
	switch name {
	case country_language.FieldCountryCode:
		m.ResetCountryCode()
		return nil
	case country_language.FieldLanguage:
		m.ResetLanguage()
		return nil
	case country_language.FieldIsOfficial:
		m.ResetIsOfficial()
		return nil
	case country_language.FieldPercentage:
		m.ResetPercentage()
		return nil
	}
	return fmt.Errorf("unknown Country_language field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CountryLanguageMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.country != nil {
		edges = append(edges, country_language.EdgeCountry)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CountryLanguageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case country_language.EdgeCountry:
		if id := m.country; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CountryLanguageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CountryLanguageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CountryLanguageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcountry {
		edges = append(edges, country_language.EdgeCountry)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CountryLanguageMutation) EdgeCleared(name string) bool {
	switch name {
	case country_language.EdgeCountry:
		return m.clearedcountry
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CountryLanguageMutation) ClearEdge(name string) error {
	switch name {
	case country_language.EdgeCountry:
		m.ClearCountry()
		return nil
	}
	return fmt.Errorf("unknown Country_language unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CountryLanguageMutation) ResetEdge(name string) error {
	switch name {
	case country_language.EdgeCountry:
		m.ResetCountry()
		return nil
	}
	return fmt.Errorf("unknown Country_language edge %s", name)
}
